# PRACTIC 1

## Ссылки
```
const int &a = 2;
a = 6; //скопировали значение
```
---
```
&a == &x (!)
```
---
```
int &arr[] // не сущ
```
- арифметики ссылок не сущ
- если удалим х, то ссылка станет невалидной(и проверить нельзя), undefined behavour
- не надо делать пустые ссылки поля(лучше указатели)
- про указатели не забываем

- (!)если в функции параметр укзаатель(ссылка), то он обязан быть const(!)
```
A copy(const A& a)
```

- отдельный метод для Clear() не надо, просто напиши деструктор

## Классы
- у класса по дефолту все приватное, у структур публичное
- каждого класса есть: 
    1) конструктор
    2) деструктор
    3) конструктор копирования
    4) оператор присваивания

## лаба
```
MyVector{
    int *data;
    int size;
    int capacity
}
MyVector(_, size = 0, capacity = 2) //изначально
//то есть это как бы лишние байты(?) и умножаем cap * 2, посмотри потом крч

MyVector::MyVector(){
    copacity = 2;
    size = 0;
    data new int[2]
}
~MyVector::~MyVector(){
    delete[] data;
}

MyVector::MyVector(**const** MyVector data){
    cap = other cap
    size...
    data = new int[cop]
    //copy data other
}// КК
```
## new
- если закончилось место, то исключение

```
new int //по умолчанию мусор
new MyArray(3) //вызывается констуртор
```

- лучше всегда делать конструктор по умолчанию

## поля
как правильно располагать?
```
class MyVector{
public:
    MyVector;
    ~MyVector;
    ..
    /методы

private:
    /поля
}
```
- загуглить паттерн синглтона
- для изменения приватных полей делай геттер/сеттер

## перегрузка функций
- ссылка не является перегрузкой
```
sum (int, int)
sum(int &, int &)
sum (const int, const int)//кроме ссылок/указателей
//error!
```

## оператор присванивания(переопределение операторов)
```
&MyVector operator =(const &MyVector other){
    if (this == &other)//самая жеская проверка, говорит что указ на одно и то же место в памяти
        {return this}
    //if (*this == other) - пробегается по всем полям и сравнивает их
    this->capacity = other cap
    this->size = other size
    delete[] data //может быть проблема, допустим при v1 = v1, нужна проверка
    data = new int[size]
    for (...) //copy
    return *this
}
```
---
MyVector v3 = v1 <=> MyVector v3(v1)
